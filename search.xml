<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人常用软件推荐]]></title>
    <url>%2F2019%2F08%2F28%2F%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[windows企业长期服务版首先是windows，可能你会问，windows有啥好推荐的，现在大家用的不都是win10吗？ 没错，都是win10，可是不同的版本，体验也是不一样的，一般人用的都是win10专业版或家庭版，现在最新的win10专业版安装好后，系统自带的商店会安装一些推广软件，本人对电脑有深度洁癖，这种行为是绝对不能容忍的。我这里推荐的是windows LTSB版本，LTSB就是长期支持更新分支（Long Time Service Branch），这个版本专门给一些企业用户的，相比一般版本会缺少很多新功能，例如没有应用商店、没有Edge浏览器，没有cortana，大家可以把Win10 TLSB看成是Windows10企业版的精简版本。LTSB是英语Long Term Servicing Branch的首字母缩写，汉语一般翻译成长期服务分支。LTSB分支是专门面向企业版的，Win10企业版LTSB分支支持周期长达10年，但只会获取安全更新(应该也可以获取热补丁更新)，而不获取功能更新，即不会增加任何新功能。这也是Win10企业版LTSB分支和Win10企业版最根本性的区别。 Win10企业版和LTSB分支Win10企业版的区别： 1、Win10企业版LTSB分支不会有Edge浏览器 2、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。 3、无Cortana 4、无任何系统自带磁贴程序 5、无应用商店 现在最新的版本是2019 LTSC版，不过我个人还在用2016 LTSB版，从16年起到现在，期间换过几个电脑，我就在用这个版本，一直觉得这个版本是最好用最稳定的版本，工作电脑也是用的这个版本。 下载链接：msdn.itellyou.cn,搜索 win ltsb 或 win ltsc 下载你需要的版本。这个网站上下载的都是官方原版ISO文件，未经任何第三方修改。 本人常用的软件推荐 聊天软件：TIM QQ企业版，没有垃圾广告 浏览器：chrome firefox Chrome主力，firefox备用 输入法：百度输入法 虽然大家一直在骂百度，不过他的输入法还是不错的，没有广告啥的 视频播放器：PotPlayer 看电影我都是下到本地观看，一直在用这个播放器 下载工具：μTorrent 和 迅雷去广告版 以前用过μTorrent，发现下载不动资源，其实是使用的姿势不对，设置一下tracker，速度飞起，前往设置教程(待写) 截图软件：PicPick 不错的截图软件 压缩软件 7zip 优秀的开源压缩软件，我用了七八年了 chrome浏览器插件推荐 Adblock Plus 广告屏蔽插件，可屏蔽大部分网页广告，从chrome商店里安装（需要梯子) YouTube Video Downloader YouTube视频下载工具，第三方chrome插件，不在chrome商店里，本地下载安装 工作相关软件 编辑器：WebStorm &amp; VS Code 主力WebStorm,VS Code备用 图像处理：PhotoShop 2017 PhotoShop插件：AssistorPS 一款PS插件，处理一些icon时很有用 PDF阅读器：Foxit Reader(福昕阅读器) 绿色小巧的PDF阅读器，功能也很强大 办公软件：Office 2013 Android 软件推荐 看图软件：快图浏览 我用的是旧版本v4.5.3，无广告 视频播放： MX Player Pro 功能丰富的播放器，可以手动添加字幕，设置字幕样式 文件相关：Root Explorer &amp; ES文件浏览器 系统相关：绿色守护 MyAndroidTools Pro 制裁一些国产软件的流氓行为 电池监控：Battery Monitor Widget Pro 这个软件可以监测电池电流，还能根据充电电流计算当前电池容量 骑行记录：行者 &amp; relive relive是国外软件，可生成一个炫酷的3D运动轨迹视频，国产手机安装较为麻烦，需安装google套件 ROOT管理：Magisk 新版miui root管理好像只能用这个]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>windows</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青海湖骑行记]]></title>
    <url>%2F2019%2F08%2F22%2F%E9%9D%92%E6%B5%B7%E6%B9%96%E9%AA%91%E8%A1%8C%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[青海湖，也就是青色的海，是由蒙语“库库淖尔”和藏语“错温布”意译而来，是中国最大的湖泊，也是著名的内陆咸水湖。 青海湖，湖面海拔3196米，位于青海湖盆地内，三面环山；其中，北面、东南面、南面分别环绕祁连山脉、日月山脉、南山山脉。不仅有丰富的高原风景，又集草原与山峰于一身，还是著名的候鸟栖息地。 环湖公路一周大约360公里，沿途风景有草原、湖泊、沙漠、山峦、查卡盐湖、油菜花、牛羊和鸟群等丰富的景观。 “环青海湖国际公路自行车赛”更是使得这一骑行圣地，广为人知，再加上青藏公路和青藏铁路沿湖而过，每年都吸引着很多骑行者慕名前往。 近年来，随着青海湖环湖旅行的知名度提高，旅游产业的发展也越来越成熟，环湖骑行的设备租赁和食宿都日臻完善。青海湖环湖公路本身是完全开放的，但有几个景点是需要收费的。 自行车托运&amp;装备相关环青海湖骑行已经是非常成熟和商业化的路线，环湖起点西海镇有很多提供自行车出租的驿站。但我还是选择带自己的车去，一是骑自己的车比较有意义，二是骑自己的车会更舒适。交通方式我选择火车，当然也可以选择高铁or飞机。 自带的装备：头盔、骑行眼镜、全指手套、袖套、腿套、打气筒、拆车&amp;修车工具、扎带×100条、折叠外胎、内胎×2、梁包、骑行服×2、骑行头巾×2、保鲜袋×20、手电筒、吹风机、移动电源（10000mAh)×2、充电器&amp;数据线、个人生活用品等。 补给品：葡萄糖粉一袋(300g)、电解质泡腾片20片、蛋白粉3份（90g）、红景天胶囊20粒。 开始我没准备租驿站的货架，买了一个这样的车尾包，后来发现这个尾包装不下这么多东西，就问驿站老板有没有快拆的货架，得到肯定的回答后，就没用这个尾包。后来有点后悔带这么多东西，有些东西基本上没用到，还增加了骑行的难度。 在驿站租的装备：货架、驼包、雨衣。 为预防高反，我提前一周买了红景天胶囊吃，不过感觉好像没什么用。 路线相关首先我在网上找了一个四天环湖线路图，如下 实际我的行程如下，标签为住宿点。 DAY1 11:00-19:30 西海镇→江西沟→黑马河 145kmDAY2 8:00-13:30 茶卡盐湖 15:00-18:00 黑马河→鸟岛 50kmDAY3 8:00-19:30 鸟岛→泉吉乡→刚察县→沙岛 120kmDAY4 9:00-11:30 沙岛→西海镇 45km START 上海→西宁因为车票比较难抢，我买的是8月13日K2816车次卧铺，上海11:03出发，14日晚上才到，全程34个小时。 拆车+装包，前后轮、前叉全拆，尽量减小体积，然后乘公交至火车站。后来有点后悔用了这个车包，因为是在是太重了，车包重7斤，车重20斤，背上还有个15斤的背包，从出门→公交站→火车这段路程非常的累，让我分分钟想把它扔了。 顺利上车，一开始我把车放在了洗漱台那个位置，后来列车员不让放，我就塞到了床底下。 经过34个小时漫长的旅程，14日晚到达西宁，随便找了个青旅住下。 8月15号早上乘大巴→西海镇，车程2个小时左右，早7点半出发，9点半点左右到达西海镇。 DAY1 西海镇→江西沟→黑马河到达西海镇汽车站后，打了个车去飞登青海湖驿站，到驿站后开始装车。装好后驿站的几个小哥都试骑了我的车，来环湖的一般是山地车，公路车也有，骑着死飞来环湖的，他们也是第一次见。 装好货架和驼包，整装待发，然后我去附近的超市买了点香蕉和几瓶水，吃了两根香蕉就出发了。 刚骑了10分钟左右，我想起有一些修车工具忘在驿站那里了，打电话给驿站小哥，驿站小哥骑了一辆电动助力山地车给我送了过来。 小哥送来工具后已经快11点了，我又重新踏上旅程。 开始前15公里有两段连续几公里的上坡，是整段路程难度都比较大的一段。 爬完坡，已经12点多，后面是一段沙漠的路段。 下午1点左右，看到路边有个小卖部，碰到一队骑友在这里休息和补给，我进去吃了一个士力架、两根香蕉、两根香肠。 吃完东西，重新上路，没多久我就超过了这队骑友。下午2点左右，到达一处可通向湖边的地方，有藏民在入口处收费，每人10元。我也进去拍了几张照。 路上又遇到一队骑友，此时路边还有盛开的油菜花，进去拍照也是要收费的，里面的马也是可以骑的。 下午4点左右，到达二郎剑景区。 下午5点左右，到达江西沟乡，江西沟乡是大多数人第一天的终点，里程约98Km。我看天色尚早，体力还比较充足，决定继续往前骑。 路上碰到两个骑马的藏民跟我喊：“扎西德勒”，我也向他们喊“扎西德勒” 出了江西沟乡，湖边也变成了牧场。然后遇到了一位骑友，他车后面挂着个实习的贴纸，我便和他边骑边聊，原来是个骑青藏线的大佬，他还有个队友在后面。 下午7点多，到达黑马河乡，我们找了个旅馆住下，然后一起去吃了晚餐。这两个老哥带的装备很多，有帐篷睡袋等，还带了个无人机。 DAY2 茶卡盐湖 黑马河→鸟岛 8月16号早上6点我就起床了，准备去湖边看日出。最佳观日点在黑马河乡东北方向，有一条小路通向湖边，距离黑马河乡两公里多，不收费。路上有载客的当地人，工具有摩托车和马，我当然是骑着车过去了。早上气温很低，温度不超过10℃，我只穿了一件薄外套，感觉较冷，湖边还有提供军大衣出租的当地人。 因天气不佳，未看到日出，稍有些遗憾。 回到旅馆，买了点早餐吃。准备前往茶卡盐湖，从黑马河乡到茶卡盐湖距离约80公里，中间有一座橡皮山海拔很高，骑车前往难度很大，我决定包车前往，旅馆老板帮我联系了一个司机。那两位老哥骑青藏线也要经过茶卡盐湖，我们早上就此分别。出发前，我加了两位老哥的微信。 前往茶卡盐湖的途中，曲折的山路。 上午10点左右到达茶卡盐湖，司机说等我们两个小时，12点钟在景区门口会合。与我同行的还有一个小哥，与他聊天得知他是徒步来环青海湖的，也是个狠人。我赤脚下水让小哥帮我拍了几张照。因为当天天气不是很好，拍出的照片不是很满意。盐湖的盐层像冰层一样，有的地方还有空洞。 不一会就到了12点，司机已经在景区门口等我们了。回到黑马河我让小哥在黑马河租个自行车骑，小哥最后还是没有租。我们一起吃了午饭，加了微信，就此分别。 我回到旅馆，睡了个午觉，下午3点，收拾行装，重新出发。 出了黑马河乡，进入环湖西路，又重新回到了湖边，这段路程景色极佳，中途有一个令人绝望的上坡。下午6点左右，到达鸟岛，找了个青旅住下。吃过晚饭，然后去超市买了第二天的早餐。在青旅遇到了一位骑友小陈，他还是在校学生，趁着暑假从成都骑过来的，我们决定第二天结伴前行。此时距离西海镇还有160km左右，我们准备第二天一口气骑完。 DAY3 鸟岛→泉吉乡→刚察县→沙岛 17日早上，我继续早起准备去看日出，因天气原因，还是未能如愿。到7点半，我喊小陈起床，一起吃了早餐，然后就出发了。 路上遇到一位骑马的藏民，还问我们骑不骑马。 还有一些骑友在举办一个业余赛事。 鸟岛九号露营地，有很多房车。 青藏铁路。 小陈没我骑的快，我经常停下等他一会。 10点半到达泉吉乡，感觉肚子有点饿，在一个超吃买了点东西吃。 出了泉吉乡，途径一条小河，河水很清澈，有很多鱼。出了泉吉乡，就基本上看不到湖面了。 12点半到达刚察县，在刚察县吃午饭。 刚察县一个装修很豪华的厕所，我戏称为五星级厕所。 出了刚察县，就有一个很长的上坡教做人，好在上坡之后就是下坡，下坡时不用脚踩就能飙到三四十码。 下午6点左右，我们发现有一条小路可通向湖边，就去湖边玩了一会。湖水也很清澈，我用舌头尝了一下湖水，也是咸的，但没有海水那么咸。后来看地图发现这只是一个小湖，叫尕海。 下午7点多，到达沙岛景区附近，此时逆风很大，骑着很费劲。我们现在景区附近的餐馆吃了晚饭，吃完发现风刮的更大了，基本骑不动了。此时距离西海镇还有40公里左右，小陈打算夜骑被我劝住了，我们就在景区的宾馆住宿。 DAY4 沙岛→西海镇 原子城纪念馆 早上我们在宾馆吃了泡面当早餐，9点多出发。途中又有几个上坡，但难度不是很大，上坡过后就基本都是下坡路了。11点到达西海镇，在一个小卖部吃了一盒牦牛酸奶。 到达西海镇后，我们去了镇上的原子城纪念馆。纪念馆主要介绍了我国核武器的发展历程，馆内展品禁止拍照。出口处有一个出售纪念品的商店，小陈买了一个纪念币，我买了一个指尖陀螺。 参观结束后，我们一起吃了个散伙饭。 然后回到驿站，把车拆了，下午乘大巴回西宁，第二天乘火车返回上海。 总结总的来说，本次骑行还是比较成功的，人和车一路上都没有意外发生，爬坡的路段我也是全程骑上去的，没有下来推车。有点后悔的就是东西带的太多，稍微增大了骑行难度，那个车包也后悔用了，下次出行我会买个手拉车，把车放在上面，就不会那么累了。可能你会好奇，死飞没有变速，爬坡是什么感受？ 感受就是虽然累，但还没有到爬不动的地步，我的车以前的齿比是48:17，来之前我换了一个飞轮，把齿比换成了48:19，稍微减小了齿比。另外爬坡的时候死飞是两只脚都能发力（前脚踩，后脚拉），所以效率反而比普通自行车要高。比较遗憾的是没看到青海湖的日出，去茶卡盐湖玩的时候天气也不是很好。 更多照片请查看相册： 青海湖骑行记 视频环湖西路放坡，危险动作，请勿模仿 使用relive APP生成的运动轨迹视频，因免费版只能生成12小时以内的运动轨迹，所以后面少了一小段。]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用AES算法加密Hexo相册]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BD%BF%E7%94%A8AES%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86Hexo%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[本教程承接上篇Hexo博客添加一级分类相册。 在上篇教程中，我们已经实现了hexo的分类相册功能。然后我发现那个大佬的相册竟然还有加密的功能（点击进入大佬的相册），在大佬的这篇教程下面，还有一个参考资料：使用AES算法加密hexo文章，可惜的是链接已经失效了，不过也没有关系，在网上查找相关资料后，我也把它实现了，本篇教程就来实现相册加密功能。 先来科普一下AES加密算法：高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 1、主题自带的加密首先我发现本主题自带一个加密功能：如下图： 它的实现效果是这样的： 在进入界面的时候就要求输入密码，不输或输入错误都会跳转到首页。 在我看了源码之后发现是这样实现的，如果文章配置了加密就在页面里加上一段js代码，源码在post.ejs文件里，如下图； 页面内生成的js代码呢，是这样的： 我们可以看到密码是直接写在页面内的，主题作者推荐使用SHA256再加密一遍密码，再用这个值当密码，防止别人识破。然而这种方式是伪加密的，不管你的密码是怎么生成的，再怎么复杂，它终究是个字符串，直接写在HTML里面，查看网页的源代码就可以看到文章的密码和内容。这种方式可以阻挡99%的人，但是对付懂行的人就不行了，有心人费点心思就能破解。 2、Hexo插件加密然后我以hexo 加密为关键字搜索相关教程，得到的结果如下： 里面的内容大同小异，不外乎两个hexo的插件：一个是hexo-blog-encrypt，另一个是hexo-encrypt。在我把两个插件都尝试过了之后，发现这两个插件只能加密文章，也就是hexo从md文件里读取到的文章内容。而我们的相册呢，是根据配置文件自动生成的，并没有在md文件里写着，实现不了加密。 好吧，那我就研究一下这两个插件的原理，看它们是如何实现文章加密的。 先使用hexo-blog-encrypt插件，给hello world这篇文章加密试试：首先启用该插件，在根目录的_config.yml中启用该插件，添加以下代码: # Security encrypt: enable: true 然后设置文章的密码，在文章头部加上password字段,密码为2233: --- title: Hello，world！ date: 2019-07-15 17:25:30 password: 2233 tags: - hello world categories: - 日志 --- 然后hexo-blog-encrypt插件就会把文章加密了，如下图： 页面结构如下： 文章的内容被加密成了这么一坨字符串，解密后变成了这样： 文章的内容，就是两个P标签。 3、插件的加密过程那一坨字符串是怎么变成两个P标签的呢，我仔细研究后发现解密的功能在blog-encrypt.js这个文件里，在知道正确密码的情况下，执行了四步转换才将那个字符串解密，源码如下： 那么这四步都干了什么呢，我把上面加密后的一坨字符串和相关js都放到一个html里在浏览器控制台调试一下，看看究竟是怎么解密的： 控制台输出如下： 我们可以看到，在第四步输出了解密后的HTML标签。 解密步骤如下： 1、根据密码使用AES算法将密文解密，解密的代码为： let content = CryptoJS.AES.decrypt(encriptHtmlStr, password); 解密出来的内容是一个JS对象，里面有一个words数组，展开后如下图： 2、将上面那个JS对象转换为utf-8码，转换后为成为一个base64字符串。 3、解码base64字符串，解码后是一个经过js转码(escape)的字符串。 4、解码(unescape)上面的字符串，最终结果为HTML标签。 既然知道了解密的过程，那么可以推断加密过程就是上述步骤的逆操作，在查看hexo-blog-encrypt的源码之后（在node_modules目录下），果不其然，找到如下代码： data.content = escape(data.content); data.content = CryptoJS.enc.Utf8.parse(data.content); data.content = CryptoJS.enc.Base64.stringify(data.content); data.content = CryptoJS.AES.encrypt(data.content, String(data.password)).toString(); CryptoJS是引入的npm插件crypto-js const CryptoJS = require('crypto-js'); 那么我们也能写一个加密函数，在生成HTML字符串的时候加密它，然后把加密后的字符串渲染出来。 4、加密辅助函数然而在实际操作的时候我发现在ejs文件里面用常规的方法引入npm插件是不行的，无论是import &#39;crypto-js&#39;还是 require(&#39;crypto-js&#39;)都是不行的。那么如何在ejs里面调用外部函数呢？ 在查看官方文档之后发现需要自己写一个辅助函数（helper），才能在ejs里调用它： 然后我们在主题根目录下新建以下目录和文件scripts/helpers/encrypt.js，encrypt.js内代码如下： /* global hexo */ 'use strict'; const CryptoJS = require('crypto-js'); hexo.extend.helper.register('aes', function(content,password){ content = escape(content); content = CryptoJS.enc.Utf8.parse(content); content = CryptoJS.enc.Base64.stringify(content); content = CryptoJS.AES.encrypt(content, String(password)).toString(); return content; }); 注册一个名为aes的辅助函数，这样才能在ejs文件里使用它。 然后将gallery.ejs文件内中间的HTML部分改成如下代码： &lt;div class="container"> &lt;div class="photo-wrapper"> &lt;% if (page.password ) { %> &lt;script src="/lib/crypto-js.js">&lt;/script> &lt;script src="/js/gallery-encrypt.js">&lt;/script> &lt;div id="hbe-security"> &lt;div class="hbe-input-container"> &lt;input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码查看内容"/> &lt;a href="javascript:;" class="btn-decrypt" id="btn_decrypt">解密&lt;/a> &lt;/div> &lt;/div> &lt;div id="mygallery"> &lt;div class="waterfall" id="encrypt-blog" style="display:none"> &lt;%- aes(imageStr, page.password) %> &lt;/div> &lt;/div> &lt;% } else { %> &lt;div class="waterfall" id="encrypt-blog"> &lt;%- imageStr %> &lt;/div> &lt;% } %> &lt;/div> &lt;/div> 初始化justifiedGallery插件的那句代码修改成下面的，就是改了一个id $("#encrypt-blog").justifiedGallery({margins: 5, rowHeight: 150}); 这段代码的作用就是判断相册是否有密码，有则加密，没有则正常渲染，密码也是写在md文件的头部，加密后页面样式和HTML结构如下： 可以看到内容已经被加密成了一坨乱码，在这里，我手动加了一个解密按钮，原来插件是没有的，然后写点css美化一下，我是加到了my.css里面 .hbe-input-container .btn-decrypt{ display: inline-block; vertical-align: top; width: 120px; height: 32px; line-height: 32px; font-size: 16px; color: #ffffff; background-color: #3f90ff; text-align: center; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; } 5、修改解密js文件因为和文章的加密有点区别，而且插件的解密操作会在id为encrypt-blog的div上加上一些样式，会导致justifiedGallery样式错乱，所以是不能直接用文章的解密js文件（/lib/blog-encrypt.js）的。此文件在发布后才会生成，在hexo-blog-encrypt插件的目录（node_modules/hexo-blog-encrypt）下也能找到，需要做些修改才能解密相册，找到该文件后复制一份，重命名为gallery-encrypt.js,放到主题目录source/js下，替换文件尾部$(document).ready()里面的代码如下： $(document).ready( function () { let password = String(getCookie(GenerateCookieName())); console.log(`Get password from Cookie:${password}`); if (password != '') { if (!decryptAES(password)) { // Delete cookie setCookie(COOKIE_NAME, password, -5); } else { document.getElementById('encrypt-blog').removeAttribute('style'); $("#encrypt-blog").justifiedGallery({margins: 5, rowHeight: 150}); } } document.getElementById('pass').onkeypress = function (keyPressEvent) { password = String(document.getElementById('pass').value); if (keyPressEvent.keyCode === 13) { const result = decryptAES(password); if (result) { document.getElementById('encrypt-blog').removeAttribute('style'); $("#encrypt-blog").justifiedGallery({margins: 5, rowHeight: 150}); setCookie(GenerateCookieName(), password, 30); } } }; $('#btn_decrypt').on('click', function () { password = String(document.getElementById('pass').value); const result = decryptAES(password); if (result) { document.getElementById('encrypt-blog').removeAttribute('style'); $("#encrypt-blog").justifiedGallery({margins: 5, rowHeight: 150}); setCookie(GenerateCookieName(), password, 30); } }); } ); 这段代码的作用就是在解密后清除id为encrypt-blog这个div的样式，然后再初始化 justifiedGallery插件，解决图片错乱的问题，还有给按钮绑定解密的操作。 至此，相册的加密功能也已经实现了。你可以前往体验一下，看你能不能破解。 6、注意事项需要注意的是上面HTML里引入的crypto-js.js这个文件，只有安装了hexo-blog-encrypt插件发布后才会生成，如果你不想安装这个插件，则需要手动安装crypto-js: npm i crypto-js, 然后在插件目录下找到crypto-js.js文件，复制出来放到source/js下，引用路径也要改一下。]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>相册</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客添加一级分类相册功能]]></title>
    <url>%2F2019%2F07%2F22%2Fhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[最近在折腾自己的博客，在折腾的过程中也参观了许多大牛的博客，发现不少博主都有个相册页面，我也想在自己的博客上面加个相册功能。但是我现在用的这个主题呢，虽然有个相册的功能，但是我感觉有点简陋，点击照片是个弹出的轮播图，照片多了的话还要一张一张的翻。如下图： 后来在网上找了不少教程，可是实现的结果大部分都是这种： 虽然有了分类的功能，但是所有照片都是在一个页面上，图片多了会影响页面加载速度，页面也会变得很长，移动端会浪费大量流量，用户体验不是很好。 该博客地址：http://lawlite.me/photos 而我想要的呢，是个类似QQ空间的相册，要有个相册目录界面，然后可以从目录页跳转至相册列表界面。 然后我翻遍了整个互联网终于找到了一个有相册分类功能的博客，该博客的相册界面是这样的： 该博客地址：http://www.rayblog.cn/album 好吧，这就是我想要的效果，而且博客下面还有教程，我研究了半天，把代码都拷到本机运行了之后，发现他这个教程也只是实现了相册的列表界面，至于目录界面是怎么弄出来的只是一笔带过。并没有实现的细节。我个人猜测他的目录界面是一个album/index.md文件，然后md文件里手动写的HTML代码。 虽然这种方式我也能实现，但我并不想这么做，因为我感觉在markdown文件里面写HTML和js不是很优雅，也有些繁琐，假如要添加一个相册的话还要手动修改里面的HTML代码，添加对应的链接。 后来我仔细研究了这个主题的源码，发现这个主题的友情链接界面实现的方式是这样的，读取sources/_data/friends.json文件,该文件内容如下： [{ "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg", "name": "码酱", "introduction": "我不是大佬，只是在追寻大佬的脚步", "url": "http://luokangyuan.com/", "title": "前去学习" }, { "avatar": "http://image.luokangyuan.com/4027734.jpeg", "name": "闪烁之狐", "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬", "url": "https://blinkfox.github.io/", "title": "前去学习" }, { "avatar": "http://image.luokangyuan.com/avatar.jpg", "name": "ja_rome", "introduction": "平凡的脚步也可以走出伟大的行程", "url": "ttps://me.csdn.net/jlh912008548", "title": "前去学习" }] 该文件包含每个友链的头像、名字、介绍、地址、标题信息，然后hexo会按照friends.ejs模板文件里的结构渲染出来列表，实现的效果就是这样的: 就是三个a标签，里面包含头像、地址等信息，点击后跳到对应的地址。 那么我们也能自定义一个相册的配置文件和模板文件，然后hexo读取这个配置文件，自动生成目录界面和列表界面，这样的话，只需要修改这个配置文件就能完成对相册的各种操作（增删改）。 好吧，有了思路，就已经成功一半了，至于代码实现呢，就只是时间问题了。花了一个周末的时间我终于把它实现了。下面是具体实现过程: 1、添加【相册】菜单这里要修改几个文件： 该主题的配置文件_config.yml ，不要跟站点根目录下的同名文件搞混了，在menu下添加以下代码: Galleries: url: /galleries icon: fa-photo 该主题的语言配置文件目录 languages下的 default.yml和zh-CN.yml，分别是英文和中文的配置文件，分别添加以下内容， galleries: galleries galleries: 相册 该主题目录下layout/_partial/navigation.ejs和layout/_partial/mobile-nav.ejs文件里添加 menuMap.set("Galleries", "相册"); 至于添加到什么位置，你打开文件就知道了，里面会有类似格式的代码，很容易找到的。 做完以上操作后，你就会发现相册的菜单已经出现了： 点击就能跳转到galleries下，然而浏览器会提示你： 因为站点下并没有galleries/index.html这个文件，如何生成这个文件呢?在站点根目录source下新建galleries目录，然后在该目录下新建index.md，就会生成index.html文件了，然而却是这个效果： 2、生成相册目录和相册列表这是为什么呢？因为hexo把这个文件当成一个普通的文章来渲染了，而我们需要自定义样式，不能让它渲染成普通的文章。要让它渲染成一个layout,也就是我们自定义的模板。需要以下操作：在index.md文件里添加以下内容，注意，那几个中划线也不要少了。 --- title: 相册 layout: "galleries" --- 首先添加自定义CSS样式文件，该主题目录下的source/css里新建gallery.css文件，复制以下css样式进去： .gallery-wrapper{ padding-top: 30px; } .gallery-wrapper .gallery-box{ padding: 5px !important; } .gallery-wrapper .gallery-item { display: block; overflow: hidden; background-color: #fff; padding: 5px; padding-bottom: 0; position: relative; -moz-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); -webkit-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); } .gallery-cover-box{ width: 100%; padding-top: 60%; text-align: center; overflow: hidden; position: relative; background: center center no-repeat; -webkit-background-size: cover; background-size: cover; } .gallery-cover-box .gallery-cover-img { display: inline-block; width: 100%; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); } .gallery-item .gallery-name{ font-size: 14px; line-height: 24px; text-align: center; color: #666; margin: 0; } .waterfall { column-count: 3; column-gap: 1em; } .photo-wrapper{ padding-top: 20px; } .photo-item { display: block; padding: 10px; padding-bottom: 0; margin-bottom: 14px; font-size: 0; -moz-page-break-inside: avoid; -webkit-column-break-inside: avoid; break-inside: avoid; background: white; -moz-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); -webkit-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); } .photo-item img { width: 100%; } .photo-item .photo-name{ font-size: 14px; line-height: 30px; text-align: center; margin-top: 10px; margin-bottom: 10px; border-top: 1px solid #dddddd; } /*适配移动端布局*/ @media only screen and (max-width: 601px) { .waterfall { column-count: 2; column-gap: 1em; } } 在该主题layout目录下新建galleries.ejs文件，添加以下代码： &lt;link rel="stylesheet" href="/css/gallery.css"> &lt;%- partial('_partial/bg-cover') %> &lt;main class="content"> &lt;div class="container"> &lt;% if (site.data &amp;&amp; site.data.galleries) { %> &lt;% var galleries = site.data.galleries; %> &lt;div class="gallery-wrapper row"> &lt;% for (var i = 0, len = galleries.length; i &lt; len; i++) { %> &lt;% var gallery = galleries[i]; %> &lt;div class="col s6 m4 l4 xl3 gallery-box"> &lt;a href="./&lt;%- gallery.name %>" class="gallery-item" data-aos="zoom-in-up"> &lt;div class="gallery-cover-box" style="background-image: url(http://图片地址.com/&lt;%- gallery.cover%>);"> &lt;/div> &lt;p class="gallery-name"> &lt;%- gallery.name %> &lt;/p> &lt;/a> &lt;/div> &lt;% } %> &lt;/div> &lt;% } %> &lt;/div> &lt;/main> 同目录下新建gallery.ejs，添加以下代码： &lt;link rel="stylesheet" href="/css/gallery.css"> &lt;link type="text/css" href="/libs/fancybox/jquery.fancybox.css" rel="stylesheet"> &lt;link type="text/css" href="/libs/justifiedGallery/justifiedGallery.min.css" rel="stylesheet"> &lt;%- partial('_partial/post-cover') %> &lt;% let galleries = []; if (site.data &amp;&amp; site.data.galleries) { galleries = site.data.galleries; } var pageTitle = page.title; function getCurrentGallery(galleries, pageTitle) { for (let i = 0; i &lt; galleries.length; i++) { if (galleries[i]['name'] == pageTitle) { return galleries[i]; } } } var currentGallery = getCurrentGallery(galleries, pageTitle) var photos = currentGallery.photos; let imageStr = '' for (var i = 0, len = photos.length; i &lt; len; i++) { var photo = photos[i]; imageStr += "&lt;a href=\"http://图片地址.com/" + photo + "\"" + " class=\"photo-item\" rel=\"example_group\"" + " data-fancybox=\"images\">" + " &lt;img src=\"http://图片地址.com/" + photo + "\"" + " alt=" + photo + ">\n" + " &lt;/a>" } %> &lt;div class="container"> &lt;div class="photo-wrapper"> &lt;div class="waterfall" id="mygallery"> &lt;%- imageStr %> &lt;/div> &lt;/div> &lt;/div> &lt;script src="/libs/fancybox/fancybox.js">&lt;/script> &lt;script src="/libs/justifiedGallery/justifiedGallery.min.js">&lt;/script> &lt;script> $("a[rel=example_group]").fancybox(); $("#mygallery").justifiedGallery({margins: 5, rowHeight: 150}); &lt;/script> 以上代码实现的功能呢，就是读取相册配置文件并把相册目录和相册列表都渲染成HTML，用&lt;% %&gt;包起来的代码是ejs语法，调试的话是在本地控制台输出的而不是浏览器，就是你输入hexo s的地方，我这里用的是WebStorm自带的终端，看下图： 另外上面代码里引用了两个jquery插件，分别是fancybox和justifiedGallery, 一个是点击弹出的轮播插件，一个是自动调整图片布局的插件，需要自行下载并放到相应目录，当然，你也可以用浏览器调试工具直接在我的博客上下载，在sources里找到对应的文件，另存为就行。 3、制作相册配置文件在站点目录sources/_data/下新建一个galleries.json的文件，模板如下： [ { "name": "2017", "cover": "2017/IMG_20171109_124516.jpg", "description": "2017年记录", "photos": [ "2017/IMG_20170924_110224.jpg", "2017/IMG_20170924_113412.jpg", "2017/IMG_20171109_124516.jpg", "2017/IMG_20171125_125304.jpg", "2017/IMG_20171126_181605.jpg" ] }, { "name": "2018", "cover": "2018/IMG_20181124_125818.jpg", "description": "2018年记录", "photos": [ "2018/IMG_20180204_113055.jpg", "2018/IMG_20180204_113302.jpg", "2018/IMG_20180204_113442.jpg", "2018/IMG_20180208_083336.jpg" ] }, { "name": "2019", "cover": "2019/IMG_20190331_165713_1.jpg", "description": "2019年记录", "photos": [ "2019/IMG_20190118_200104.jpg", "2019/IMG_20190118_200120.jpg", "2019/IMG_20190118_200456.jpg" ] } ] 就是一个包含多个相册的列表JSON，每个相册有以下字段，name是相册标题，cover是封面图片，从相册里随便选一个就行，description是相册介绍，photos是图片列表。图片较少的话手动复制进去就行，如果你图片较多的话推荐使用脚本之类的东西自动生成，我是使用了上面博客里的js文件生成的。我这里使用了七牛对象存储做为图床，需要在代码里加上七牛的地址才能正常显示。 配置文件建好了之后还没完，只剩最后一个步骤了，在galleries下建立对应的相册名称目录和文件，比如我这三个相册需要建 2017 2018 2019三个目录，然后下面再分别新建index.md文件，文件内容为: --- title: 2017 layout: "gallery" --- 建好相应目录和文件之后，如果你的图片路径也没有错的话，相册目录和列表就都会渲染出来了，如下所示： 4、照片列表的布局选择上面的博客用的布局都比较简单粗暴，都是固定的大小和宽高比。但是不同的图片有不同的宽高比，用这种模式的话图片有两种显示方式，一是强制缩放到固定的宽高，二是裁切只显示一部分，但是都有缺点，第一个会图片会变形，第二个图片显示不全。那么有没有两全齐美的办法呢？答案是肯定的。首先我选用的是瀑布流布局，用CCS3的新特性实现的，这种模式的特点是等宽布局，固定列数，图片高度自适应，如下图： 看起来似乎没什么问题，高端大气上档次，然而做好了我发现图片的排列顺序是这个样子的，是按列竖向排列的，不太符合阅读习惯，PASS。 另外一种布局呢是等高布局，如图； 这种布局是等高布局，图片高度一致，宽度自适应，图片托管网站flickr就是用的这种模式，但是用CSS方法是实现不了的，因为每一行最后张图片不一定能正好撑满这一行，需要用js动态设置图片的宽高来实现，上面引用的justifiedGallery插件就是来完成这个的。下面代码的功能就是初始化这个插件，间距是5px，每一行的高度是150px。 $("#mygallery").justifiedGallery({margins: 5, rowHeight: 150}); 这两种布局呢，上面的代码里都是包含了的。是可以手动切换的。只需要把上面那句代码注释掉就会切换到瀑布流布局，效果如下图： 当然，你要是对我写的样式不满意的话也可以自己修改代码，边框和文件名都是可以去掉的。 5、图床相关事项2019-08-28更新: 最初我是采用的七牛对象存储当为图床，但是我发现一个问题，在相册列表界面下，相册图片较多或图片体积很大的情况下加载速度会很慢，也会浪费大量的流量。七牛CDN免费流量只有10G，然而我还作死的把几个图片的链接地址放到了某论坛上，图片也没有做任何处理，一个图片为几MB大小，在我放出外链几个小时之后，CDN流量就爆了，超出了约60G： 为了防止以后再发生这样的事，减少CDN流量消耗，我想到了如下两种方案： 一是手动生成图片的缩略图到另外一个新目录，保持与原相册目录结构一致。比如我一个图片路径为 /gallery/2017/XXX.jpg,缩略图结构应为/gallery-tiny/2017/XXX.jpg。 在相册列表界面应使用缩略图而不是使用原图。上面代码中 a标签里的地址是大图地址，点击才会加载，img标签里的地址是缩略图地址。 缩略图大小我调整为600px宽度，这样每个图片体积可减少到100KB以下。这样一个100张图片的相册，缩略图也不超过10MB。缩略图我使用 Light Image Resizer 软件批量生成。 上面对应的代码需要改为: imageStr += "&lt;a href=\"http://imgs.liyangzone.com/" + photo + "\"" + " class=\"photo-item\" rel=\"example_group\"" + " data-fancybox=\"images\">" + " &lt;img src=\"http://imgs.liyangzone.com/gallery-tiny/" + photo + "\"" + " alt=" + photo + ">" + " &lt;/a>" 二是使用七牛自带的图片样式功能，该功能提供简单快捷的图片格式转换、缩略、剪裁功能。只需要填写几个参数，即可对图片进行缩略操作，生成各种缩略图。比如我建立了一个名为 w33 的图片样式，该样式的功能就是生成原图33%大小的缩略图。假如一个100×100的图片，在图片地址后面加上这个样式后就变成33×33大小的了。对应代码需改为： imageStr += "&lt;a href=\"http://imgs.liyangzone.com/" + photo + "!w95\"" + " class=\"photo-item\" rel=\"example_group\"" + " data-fancybox=\"images\">" + " &lt;img src=\"http://imgs.liyangzone.com/" + photo + "!w33\"" + " alt=" + photo + ">" + " &lt;/a>" 列表页使用33%大小的样式，查看大图使用95%大小的。上面的叹号是样式分隔符，七牛默认的分隔符有四个: - _ ! / 也可以改成下面的： ~ ` @ $ ^ &amp; * ( ) + = { } [ ] | : ; " ' &lt; > 生成的图片地址是这样的,你可以复制到地址栏查看效果： http://imgs.liyangzone.com/2017/IMG_20170508_163002.jpg!w33 http://imgs.liyangzone.com/2017/IMG_20170508_163002.jpg!w75 另外建议开启七牛的原图保护功能并配置Referer防盗链，防止被恶意刷流量。 我目前使用的是第一种方案，只是把缩略图放到腾讯CDN了，不想麻烦的可以使用第二种。]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>添加相册</tag>
        <tag>分类相册</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之再学习]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%89%8D%E7%AB%AF%2FJavaScript%E4%B9%8B%E5%86%8D%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概览JavaScript 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。需要注意的一个主要区别是 JavaScript 不支持类，类这一概念在 JavaScript 通过对象原型（object prototype）得到延续。另一个主要区别是 JavaScript 中的函数也是对象，JavaScript 允许函数在包含可执行代码的同时，能像其他对象一样被传递。 数据类型和结构1. 动态类型JavaScript是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据： var foo = 42; // foo is a Number now var foo = "bar"; // foo is a String now var foo = true; // foo is a Boolean now 2. 数据类型最新的ECMAScript标准定义了 7 种数据类型: 6 种原始类型 Null (空, 只有一个值null) Undefined (未定义, 一个没有被赋值的变量的默认值是undefined): Boolean (布尔, 可以有两个值：true 和 false) Number (数字) String (字符串) Symbol (符号, ECMAScript 6 新定义的类型，表示独一无二的值) 和 Object (对象) Function (函数) Array (数组) Date (日期) JSON (JS对象标识,来序列化对象、数组、数值、字符串、布尔值和 null) Math (数学方面的计算) RegExp (正则表达式) Error (错误) Map Set 内置对象 这里的内置对象指的是在全局作用域(global scope)中的对象，由于很多，不再一一列出说明，更全面的解释在这里。 全局对象本身可通过this操作符在全局作用域中获得。实际上，全局作用域就是由全局对象的各个属性组成的（包括继承来的属性）。 严格模式除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 严格模式可以应用到整个script标签或个别函数中。设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 为某个script标签开启严格模式进入严格模式的标志，是下面这行语句： 'use strict' 为某个函数开启严格模式function strict(){ // 函数级别严格模式语法 'use strict'; return "I'm a strict mode function! " + nested(); } function notStrict() { return "I'm not strict."; } 相等性判断JavaScript提供三种不同的值比较操作： 严格相等 (“triple equals” 或 “identity”)，使用=== 宽松相等 (“double equals”) ，使用== 以及Object.is (ECMAScript 2015/ ES6 新特性) 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ); 而Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而Object.is(NaN，NaN)将为 true。 作用域作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域。一般来说以下几种情形： 最外层函数和在最外层函数外面定义的变量拥有全局作用域。 所有未定义而直接赋值的变量自动声明为拥有全局作用域。 所有window对象的属性拥有全局作用域。如：window.name、window.location等。 注：全局变量存在于程序的整个生命周期。没有块级作用域。 局部作用域局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。 作用域链JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是Scope，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 因为全局变量总是存在于运行时上下文作用域链的最末端。所以，在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。 with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。 person = {name: "yhb", age: 22, height:175, wife: {name: "lwy", age: 21}}; with (person.wife) { console.log(name); } with语句将person.wife添加到当前作用域链的头部，所以输出的就是：lwy；with语句结束后，作用域链恢复正常。 当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。注：在程序中应避免使用with语句。 闭包(Closures)一个示例如何从外部读取局部变量？ function f1() { var n=999; function f2() { alert(n); // 999 } } 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ function f1() { var n=999; function f2() { alert(n); // 999 } return f2; } var result=f1(); result(); // 999 闭包解释 闭包定义：闭包是一个函数和函数所声明的词法环境的结合。 在上面的代码中，f2函数就是闭包。闭包（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收。 立即执行函数表达式有时你想模拟一个模拟块级作用域，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做IIFE(立即执行函数表达式(Immediately Invoked Function Expression))： (function () { // 块开始 var tmp = ...; // 非全局变量 }()); // 块结束 用闭包模拟私有方法JavaScript 并不提供原生的支持私有方法，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(Counter.value()); /* logs 0 */ Counter.increment(); Counter.increment(); console.log(Counter.value()); /* logs 2 */ Counter.decrement(); console.log(Counter.value()); /* logs 1 */ 上面创建了一个环境，为三个函数所共享：Counter.increment, Counter.decrement和Counter.value。该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为privateCounter的变量和名为changeBy的函数。这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。 注意： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 内存机制首先JavaScript中的变量分为基本类型和引用类型。 基本类型就是保存在栈内存中的简单数据段。基本类型有Undefined、Null、Boolean、Number和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。 引用类型指的是那些保存在堆内存中的对象。引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。 为什么会有栈内存和堆内存之分？与垃圾回收机制有关，为了使程序运行时占用的内存最小。 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的； 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。 垃圾回收机制Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 清除方式 标记清除：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 原型(prototype)原型是一个对象，其他对象可以通过它实现属性继承。JavaScript的对象中都包含了一个Prototype内部属性，这个属性所对应的就是该对象的原型。Prototype作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了__proto__这个非标准的访问器。 所有的对象都有__proto__属性，该属性对应着该对象的原型。 所有的函数对象都有prototype属性，该属性的值会被赋值给该函数创建的对象的__proto__属性 所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数 函数对象和原型对象通过prototype和constructor属性进行相互关联 Object实例对象的原型obj.__proto__就是Object.prototype hasOwnProperty是Object.prototype的一个方法，该方法能判断一个对象是否包含自定义属性而不是原型链上的属性，因为”hasOwnProperty” 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数 原型链因为每个对象和原型都有原型，对象的原型指向对象的父，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。 当通过原型链查找一个属性的时候，首先查找的是对象本身的属性，如果找不到才会继续按照原型链进行查找。这样一来，如果想要覆盖原型链上的一些属性，我们就可以直接在对象中引入这些属性，达到属性隐藏的效果。 对象创建方式1. Object构造函数方式var Person = new Object(); Person.name = 'Nike'; Person.age = 29; 这行代码创建了Object引用类型的一个新实例，然后把实例保存在变量Person中。 2. 对象字面量方式var Person = { name: 'Nike'; age: 29; }; 对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性对象的过程。 注：前两种方法的缺点在于：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。 3. 工厂模式function createPerson(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() { alert(this.name); }; return o; } var person1 = createPerson('Nike', 29, 'teacher'); 在使用工厂模式创建对象的时候，我们都可以注意到，在createPerson函数中，返回的是一个对象。但我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。 4. 构造函数方式function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name); }; } var person1 = new Person('Nike', 29, 'teacher'); alert(person1 instanceof Object); //ture 对比工厂模式，我们可以发现以下区别： 没有显示地创建对象 直接将属性和方法赋给了this对象 没有return语句 终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测： 那么构造函数确实挺好用的，但是它也有它的缺点：就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法。 5. 原型创建对象模式function Person(){} Person.prototype.name = 'Nike'; Person.prototype.age = 20; Person.prototype.jbo = 'teacher'; Person.prototype.sayName = function() { alert(this.name); }; var person1 = new Person(); var person2 = new Person(); person1.name = 'Greg'; alert(person1.name); //'Greg' --来自实例 alert(person2.name); //'Nike' --来自原型 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。 这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 6. 组合使用构造函数模式和原型模式function Person(name, age, job) { this.name = name; this.age = age; this.job = job; } Person.prototype = { constructor: Person, sayName: function(){ alert(this.name); }; } var person1 = new Person('Nike', 20, 'teacher'); 7. 动态原型模式function Person(name, age, job) { this.name = name; this.age = age; this.job = job; if (typeof this.sayName != 'function') { Person.prototype.sayName = function() { alert(this.name); } } } var person1 = new Person('Nike', 20, 'teacher'); person1.sayName(); 动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。 8. 寄生构造函数方式function Person(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() { alert(this.name); }; return o; } var person1 = new Person('Nike', 29, 'teacher'); 寄生模式和工厂模式几乎一样，寄生模式和工厂模式的区别： 寄生模式创建对象时使用了new关键字 寄生模式的外部包装函数是一个构造函数 作用:寄生模式可以在特殊的情况下为对象来创建构造函数,原因在于我们可以通过构造函数重写对象的值，并通过return返回。重写调用构造函数(创建的对象的实例)之后的对象实例的新的值。 9. 稳妥构造函数方式function Person(name, age, job) { var o = new Object(); o.sayName = function() { alert(this.name); }; return o; } var person = new Person('Nike', 29, 'teacher'); person.sayName(); // 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值 道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，是指没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同： 一是新创建对象的实例方法不引用this； 二是不使用new操作符调用构造函数。 注：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。 并发模型和事件循环(event loop)JavaScript 的并发模型基于事件循环。 1. 运行时概念栈函数调用形成了一个栈帧。 function foo(b) { var a = 10; return a + b + 11; } function bar(x) { var y = 3; return foo(x * y); } console.log(bar(7)); 当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。 堆对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。 队列一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈拥有足够内存时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）。当栈再次为空的时候，也就意味着消息处理结束。 2. 事件循环之所以称为事件循环，是因为它经常被用于类似如下的方式来实现： while (queue.waitForMessage()) { queue.processNextMessage(); } 如果当前没有任何消息，queue.waitForMessage 会等待着同步将要到来的消息。 每一个消息完整的执行后，其它消息才会被执行。这个模型的一个缺点在于当一个消息的完成耗时过长，网络应用无法处理用户的交互如点击或者滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个比较好的解决方案是使消息处理变短且如果可能的话，将一个消息拆分成几个消息。 在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。 3. 绝不阻塞事件循环(event loop)模型特性在于它永不阻塞。通常由事件或者回调函数进行 I/O (input/output)处理 。 参考文档： MDN]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础教程]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%89%8D%E7%AB%AF%2FJavaScript%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、JavaScript介绍JavaScript是目前所有主流浏览器上唯一支持的脚本语言，这也是早期JavaScript的唯一用途。其主要作用是在不与服务器交互的情况下修改HTML页面内容，因此其最关键的部分是DOM（文档对象模型），也就是HTML元素的结构。通过Ajax可以使HTML页面通过JavaScript，在不重新加载页面的情况下从服务器上获取数据并显示，大幅提高用户体验。通过JavaScript，使Web页面发展成胖客户端成为可能。 语言的性质本节对JavaScript的性质做简要介绍，以帮你理解一些疑问。 JavaScript和ECMAScript（JavaScript versus ECMAScript）编程语言称为JavaScript，语言标准被称为ECMAScript。他们有不同名字的原因是因为“Java”已经被注册为商标（属于Oracle）。目前，只有Mozilla被正式允许使用“JavaScript”名称，因为很久以前他们得到一份许可。因此，开放的语言标准拥有不同的名字。当前的JavaScript版本是ECMAScript 6，ECMAScript 7当前是开发版。 JavaScript之父，Brendan Eich迅速了创建一门编程语言。（否则，Netscape将使用其他技术）。他借鉴了几门其他语言的一些特性： JavaScript借鉴了Java的语法和如何区分原始值和对象。 JavaScript的函数设计受Scheme和AWK的启发——他们（的函数）都是第一类（first-class）对象，并且在语言中广泛使用。闭包使他们（函数）变成强大的工具。 Self影响了JavaScript独一无二的面向对象编程(OOP)风格。它的核心思想（在这里我们没有提到）非常优雅，基于此创建的语言非常少。但后面会提到一个简单的模式照顾大部分用例。JavaScript面向对象编程的杀手级特性是你可以直接创建对象。不需要先创建类或其他类似的东西。 Perl和Python影响了JavaScript字符串，数组和正则表达式的操作。 JavaScript在最初的时候并不是一个完善的语言，因此也导致JavaScript遗留了很多令人诟病的问题。在开发稍大规模的应用时会显得力不从心，但是由于JavaScript本身是一种非常灵活的语言，因此在它的基础上开发程序库比较容易，因此出现了一大批非常优秀的第三方库，如jQuery，ExtJS，underscorejs，backbone等等，由于这些第三方库，JavaScript变得非常简单。其中jQuery的使用非常广泛，它大幅简化了DOM和Ajax，已经成为了很多网站的标配。jQuery虽然基于JavaScript，但它提供了另外一种编程范式，也就是逻辑式编程，与SQL和正则表达式类似。 JavaScript能做什么 如上图，JavaScript作为Github上最流行、最火的编程语言，几乎无所不能。这里是PuYart的关于JavaScript就要统治世界了的文章，可以让我们了解JavaScript到底能做什么的一些介绍。 Web前端(各种前端工具类库、前端框架、动画效果、数据可视化等) 服务端开发(Node.js) 移动应用或者Hybrid App(Cordova) 桌面应用(NW.js、Electron) 游戏(Unity3D、Cocos2d-js、Pomelo) VR(JavaScript在VR世界的应用) 硬件、嵌入式物联网等(Tessel：用JavaScript做嵌入式开发) 操作系统(NodeOS) Atwood’s Law: any application that can be written in JavaScript, will eventually be written in JavaScript.(Atwood定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。) 二、 JavaScript语法语句和表达式了解JavaScript的语法，先来了解两个主要的语法类型：语句和表达式。 语句通常是“做某些事情”。程序是一组语句的序列。举个例子，下面声明（创建）一个变量 foo： var foo; 表达式是产生“值”。他们通常位于赋值操作的右边、函数参数等。举个例子： 3 * 7 语句和表达式之间的区别最好通过实例说明，JavaScript（像Java）有两种不同的方式实现if-then-else。一种是用语句： var x; if (y >= 0) { x = y; } else { x = -y; } 另一种是表达式： var x = y >= 0 ? y : -y; 你可以将后者作为函数参数（但前者不行）： myFunction(y >= 0 ? y : -y) 最后，每当JavaScript期待一个语句，你也可以用一个表达式代替。例如： foo(bar(7, 1)); foo(...);是一个语句（也叫做表达式语句），bar(7, 1)则是一个表达式。他们都实现函数调用。 流程控制语句和语句块流程控制语句，其语句体可以是单条语句。举两个例子： if (obj !== null) obj.foo(); while (x > 0) x--; 然而，任何语句总能被语句块代替，花括号包含零或多条语句。因此，你也可以这样写： if (obj !== null) { obj.foo(); } while (x > 0) { x--; } 为便于程序的阅读和维护，推荐使用后一种方式，即语句块方式。 分号JavaScript中的分号是可选的。但省略（分号）可能会带来意想不到的结果，所以我建议还是写上分号。 正如上面所看到的，分号作为语句的结尾，但语句块不需要。仅有一种情况下你能看到语句块后面有分号——函数表达式后面的函数体块。表达式作为语句的结尾，后面是分号： var x = 3 * 7; var f = function () { }; 注释JavaScript的注释有两种形式：单行注释和多行注释。单行注释以//开头，以换行符结尾： x++; // 单行（single-line）注释 多行注释用/**/包裹 /* 这是多行注释 多行哦 */ 三、变量和赋值JavaScript中的变量在使用前必须先声明，否则会报错引用错误（Reference Error）： var foo; // 声明变量“foo” 赋值你可以在声明变量的同时为其赋值： var foo = 6; 你也可以给已经存在的变量重新赋值： foo = 4; // 更改变量的值 复合赋值操作符有很多复合赋值操作符，例如+=。下面的两个赋值操作等价： x += 1; x = x + 1; 标识符和变量名标识符就是事物的名字，在JavaScript中他们扮演不同的语法角色。例如，变量的名称是一个标识符。 大体上，标识符的第一个字符可以是任何Unicode字符、美元标志符（$）或下划线（_）。后面可以是任意字符和数字。因此，下面全是合法的标识符： arg0 _tmp $elem π 注意：首字符不能是数字，如果是数字的话，该如何区分是数字还是变量呢？ 一些标识符是“保留关键字”——他们是语法的一部分，不能用作变量名。从技术上讲，下面三个标识符不是保留字，但也不应该作为变量名： Infinity NaN undefined 四、值JavaScript有所有我们期待的编程语言值类型：布尔，数字，字符串，数组等。JavaScript中的所有值都有属性。每个属性有一个键（或名字）和一个值。你可以使用点（.）操作符读取属性： value.propKey 举个例子：字符串abc有属性lenght（长度） var str = 'abc'; console.log(str.length); // 得到3 上面的代码也可以写成下面这样： 'abc'.length // 得到3 点操作符也可以用来给属性赋值： var obj = {}; // 空对象 obj.foo = 123; // 创建属性“foo”，设置它为123 console.log(obj.foo); // 得到123 你也可以通过它（.）调用方法： 'hello'.toUpperCase(); // 得到HELLO 上面，我们在值hello上面调用方法toUpperCase()。 原始类型值和对象JavaScript定义了不同值之间的区别： 原始值包括：boolean，number，string，null和undefined。 所有其他的值都是对象。实际上对象被定义为——所有不为原始值的值。 两者之间的主要区别在于他们是如何被比较的：每一个对象有一个独一无二的标志，并且仅和自己相等： var obj1 = {}; // 一个空对象 var obj2 = {}; // 另一个空对象 obj1 === obj2 // false obj1 === obj1 // true 相反，所有原始值只要编码值相同就被认为是相同的： var prim1 = 123; var prim2 = 123; prim1 === prim2 // true 原始类型值下面全是原始类型值（简称：原始值）： 布尔类型：true，false 数字类型：1736，1.351 字符串类型: ‘abc’，”abc” 两个“无值（non-values）”：undefined，null原始值的特征： 值做比较时,“内容”做比较。 3 === 3 // true 'abc' === 'abc' // true 无法更改：值的属性无法更改，无法添加和移除属性，获取未知属性总返回undefined。 var str = 'abc'; str.foo = 3; // try to create property `foo` ⇒ no effect str.foo // unknown property ⇒ undefined 对象对象的类型所有非原始值的值都是对象。最常见的几种对象类型是： 简单对象（类型是Object）能通过对象字面量创建： { firstName: ‘Jane’, lastName: ‘Doe’ } 上面的对象有两个属性：firstName属性的值是“Jane”，lastName属性的值是“Doe”。 数组（类型是Array）能通过数组字面量创建： [ ‘apple’, ‘banana’, ‘cherry’ ] 上面的数组有三个元素，可以通过数字索引访问。例如“apple”的索引是0。 正则表达式对象（类型是RegExp）能通过正则表达式字面量创建。 /^a+b+$/ 对象的特征 比较的是引用：比较的是标识符，每个值有自己的标识符。 {} === {} // 两个不同的空对象, false var obj1 = {}; var obj2 = obj1; obj1 === obj2 // true 默认可以更改。 var obj = {}; obj.foo = 123; obj.foo //123 所有的数据结构（如数组）都是对象，但并不是所有的对象都是数据结构。例如：正则表达式是对象，但不是数据结构。 undefined 和 nullJavaScript有两个“无值）”：undefined和null。 undefined的意思是“没有值”。未初始化的变量是undefined： var foo; foo // undefined 读取不存在的属性时，将返回undefined： > var obj = {}; // 空对象 > obj.foo // undefined 缺省的参数也是undefined： function f(x) { return x; } f(); //undefined null的意思是“没有对象”。它被用来表示对象的无值（参数，链上的对象等）。 通常情况下你应该把undefined和null看成是等价的，如果他们代表相同意义的无值的话。检查他们的一种方式是通过严格比较： if (x === undefined || x === null) { ... } 另一种在实际中使用的方法是认为undefined 和 null 都是false： if (!x) { ... } 警告：false，0，NaN 和 “” 都被当作false。 包装类型对象类型的实例Foo（包括内建类型，例如Array和其他自定义类型）从对象Foo.prototype上获取方法。你可以通过读取这个方法的方式（不是调用）验证这点： [].push === Array.prototype.push // true 相反，原始类型是没有类型的，所以每个原始类型有一个关联类型，称之为包装类型： 布尔值的包装类型是 Boolean。布尔值从Boolean.prototype上获取方法： > true.toString === Boolean.prototype.toString //true 注意：包装类型名字的首字母是大写的B。如果在JavaScript中布尔值的类型可以访问，那么它可能会被转换为布尔对象。 数字值的包装类型是Number。 字符串值的包装类型是String。 包装类型也有实例（他们的实例是对象），但不常用。相反，包装类型有其他用处：如果你将他们作为函数调用，他们可以将值转换为原始类型。 Number('123') //123 String(true) //'true' 通过typeof和instanceof将值分类有两个操作符可以用来将值分类：typeof主要用于原始值，instanceof主要用于对象。 typeof 使用方法如下：typeof «value» typeof返回描述value“类型”的一个字符串。例如： typeof true //'boolean' typeof 'abc' //'string' typeof {} // 空对象字面量,'object' typeof [] // 空数组字面量,'object' 下面列出了typeof操作的所有结果： 操作数 结果 undefined &#39;undefined&#39; null &#39;object&#39; Boolean value &#39;boolean&#39; Number value &#39;number&#39; String value &#39;string&#39; Function &#39;function&#39; All other values &#39;object&#39;有两个结果和我们上面说的的原始值与对象是矛盾的： 函数的类型是function而不是object。因为函数（类型为“function”）是对象（类型是对象）的子类型，这不是一个错误。 null的类型是object。这是一个bug，但从没被修复，因为修复后会破坏现有的代码。 instanceof使用方法如下：«value» instanceof «Constr» 如果value是一个对象，并且value 是由构造函数Constr创建的（参考：类）。例如： var b = new Bar(); // 通过构造函数Bar创建对象 b instanceof Bar //true {} instanceof Object //true [] instanceof Array //true 深入阅读 探索JavaScript中Null和Undefined的深渊 五、布尔布尔类型原始值包括true和false。下面的操作符会得到布尔值： 二元逻辑运算符：&amp;&amp;（与），||（或） 前缀逻辑运算符：!（非） 等值运算符：=== !== == != 比较运算符（字符串或数字）：&gt; &gt;= &lt; &lt;= 真值和假值每当JavaScript希望一个布尔值时（例如：if语句的条件），可以使用任何值。它将被理解（转换）为true或false。下面的值被理解为false： undefined, null 布尔: false 数字: 0, NaN 字符串: ‘’ 所有其他值被认为true。被理解为false的值称为假值，被理解为true的值称为真值。可以使用Boolean作为函数，测试值被理解为什么。 Boolean(undefined) //false Boolean(0) //false Boolean(3) //true 二元逻辑运算符JavaScript中的二元逻辑运算符是短路运算——如果第一个操作数可以确定结果，第二个操作数将不被验证（运算）。例如，在下面的代码中，函数foo()永远不会被调用。 false &amp;&amp; foo() true || foo() 此外，二元逻辑运算符会返回操作数中的一个，可能是一个布尔值，也可能不是。 与：如果第一个操作数是假值，返回第一个。否则返回第二个操作数。 NaN &amp;&amp; 'abc' //NaN 123 &amp;&amp; 'abc' //'abc' 或：如果第一个操作数是真值，返回第一个。否则，返回第二个操作数。 'abc' || 123 //'abc' '' || 123 //123 等值运算符在JavaScript中检测相等，你可以使用严格相等（===）和严格不等（!==）。或者你也可以使用非严格相等（==）和非严格不等（!=）。 经验规则：总是用严格运算符，假装非严格运算符不存在。严格相等更安全。 深入阅读 在JavaScript中什么时候使用==是正确的？ 六、数字JavaScript中的所有数字都是浮点型（虽然大部分的JavaScript引擎内部也使用整数）。至于为什么这样设计，查看这里（每一个JavaScript开发者应该了解的浮点知识）。 1 === 1.0 //true 特殊数字： NaN (“不是一个数字 not a number”): 错误值。 Number('xyz') // 'xyz' 不能被转换为数字得到:NaN Infinity：也是最大错误值（无穷大） 3 / 0 //Infinity Math.pow(2, 1024) // 数字太大了,得到Infinity Infinity有时很有用，因为它比任何其他数字都大。同样，-Infinity 比其他任何数字都小。 JavaScript有两个零，+0和-0。它（js引擎）通常不让你看到，并简单将两个零都显示为0： +0 //0 -0 //0 因此最好假装只有一个零（正如我们看到假值时所做的那样：-0 和 +0 都是假值）。 运算符JavaScript中有下列算数运算符： 加: number1 + number2 减: number1 - number2 乘: number1 * number2 除: number1 / number2 模: number1 % number2 自增: ++variable, variable++ 自减: –variable, variable– 负值: -value 正值（转换为数字）: +value 全局对象Math通过函数提供更多算数运算操作。 JavaScript中也有位运算符（例如：&amp;）。 七、字符串字符串可以直接通过字符串字面量创建。这些字面量被单引号或双引号包裹。反斜线（\）转义字符并且产生一些控制字符。例如： 'abc' "abc" 'Did she say "Hello"?' "Did she say \"Hello\"?" 'That\'s nice!' "That's nice!" 'Line 1\nLine 2' // 换行 'Backlash: \\' 可以通过方括号访问单个字符： var str = 'abc'; str[1] //'b' length属性是字符串的字符数量。 'abc'.length //3 提醒：字符串是不可变的，如果你想改变现有字符串，你需要创建一个新的字符串。 字符串运算符字符串可以通过加号操作符（+）拼接，如果其中一个操作数为字符串，会将另一个操作数也转换为字符串。 var msgCount = 3; 'You have '+ msgCount + ' messages' //'You have 3 messages' 连续执行拼接操作可以使用+=操作符： var str = ''; str += 'Multiple '; str += 'pieces '; str += 'are concatenated.'; console.log(str); //'Multiple pieces are concatenated.' 字符串方法字符串有许多有用的方法。例如： 'abc'.slice(1) // 复制子字符串,得到索引1及其之后的字符串，即：'bc' 'abc'.slice(1, 2) //得到索引1和2之间的字符串，即：'b' '\t xyz '.trim() // 移除空白字符，即：'xyz' 'mjölnir'.toUpperCase() //转成大写，即：'MJÖLNIR' 'abc'.indexOf('b') // 查找第一个b的索引，即：1 'abc'.indexOf('x') //没有返回-1 八、语句条件（Conditionals）if语句通过布尔条件决定执行那个分支： if (myvar === 0) { // then } if (myvar === 0) { // then } else { // else } if (myvar === 0) { // then } else if (myvar === 1) { // else-if } else if (myvar === 2) { // else-if } else { // else } 下面的switch语句，furit的值决定那个分支被执行。 switch (fruit) { case 'banana': // ... break; case 'apple': // ... break; default: // 所有其他情况 // ... } 循环（Loops）for 循环的格式如下： for(初始化; 当条件成立时循环; 下一步操作) 例子： for (var i=0; i &lt; arr.length; i++) { console.log(arr[i]); } 当条件成立时while循环继续循环它的循环体。 // 和上面的for循环相等 var i = 0; while (i &lt; arr.length) { console.log(arr[i]); i++; } 当条件成立时，do-while循环继续循环。由于条件位于循环体之后，所以循环体总是被至少至少执行一次。 do { // ... } while(条件); 在所有的循环中： break中断循环 continue开始一个新的循环迭代 九、函数定义函数的一种方法是通过函数声明： function add(param1, param2) { return param1 + param2; } 上面的代码定义一个名称叫做add的函数，有两个参数param1和param2，并且返回参数的和。下面是如何调用这个函数： add(6, 1) //7 add('a', 'b') //'ab' 另一种定义add()函数的方法是通过函数表达式： var add = function (param1, param2) { return param1 + param2; }; 函数表达式产生一个值，因此可以直接将函数作为参数传递给其他函数： someOtherFunction(function (p1, p2) { ... }); 函数声明提升函数声明会被提升，他们全被移动到当前作用域开始之处。这允许你在函数声明之前调用它们： function foo() { bar(); // 没问题，bar被提升 function bar() { ... } } 注意：虽然变量声明也会被提升，但赋值的过程不会被提升： function foo() { bar(); // 有问题，bar是undefined var bar = function () { // ... }; } 特殊变量参数在JavaScript中你可以调用任意函数并传递任意数量的参数——语言绝不会“抱怨”（参数检测）。都可以正常工作，然而，使所有参数可访问需要通过特殊变量arguments。arguments看起来像数组，但它没有数组的方法（称为类数组 array-like）。 function f() { return arguments } var args = f('a', 'b', 'c'); args.length //3 args[0] // 获取索引为0的元素,'a' 太多或太少参数让我们通过下面的函数探索JavaScript中传递太多或太少参数时如何处理 function f(x, y) { console.log(x, y); } 多出的参数将被忽略（可以通过arguments访问）： f('a', 'b', 'c') //a b 缺少的参数将会是undefined： f('a') //a undefined f() //undefined undefined 可选参数下面是一个常见模式，给参数设置默认值： function pair(x, y) { x = x || 0; // (*) y = y || 0; return [ x, y ]; } 在（*）这行，如果x是真值（除了：null，undefined 等）， 操作符返回x。否则，它返回第二个操作数。 pair() //[ 0, 0 ] pair(3) //[ 3, 0 ] pair(3, 5) //[ 3, 5 ] 强制数量如果你想强制参数的数量，你可以检测arguments.length： function pair(x, y) { if (arguments.length !== 2) { throw new Error('Need exactly 2 arguments'); } ... } 将arguments 转换为数组arguments不是一个数组，它仅仅是类数组（array-like）：它有一个length属性，并且你可以通过方括号索引方式访问它的元素。然而，你不能移除元素，或在它上面调用任何数组方法。因此，有时你需要将其转换为数组。这就是下面函数的作用。 function toArray(arrayLikeObject) { return [].slice.call(arrayLikeObject); } 十、异常处理异常处理最常见的方式像下面这样： function throwException() { throw new Error('Problem!'); } try { throwException(); } catch (e) { console.log(e); // 错误：信息 console.log(e.stack); // 非标准，但大部分浏览器支持 } try分支包裹易出错的代码，如果try分支内部抛出异常，catch分支将会执行。 十一、严格模式严格模式开启检测和一些其他措施，使JavaScript变成更整洁的语言。推荐使用严格模式。为了开启严格模式，只需在JavaScript文件或script标签第一行添加如下语句： 'use strict'; 你也可以在每个函数上选择性开启严格模式，只需将上面的代码放在函数的开头： function functionInStrictMode() { 'use strict'; } 下面的两小节看下严格模式的三大好处。 明确错误让我们看一个例子，严格模式给我们明确的错误，否则JavaScript总是静默失败：下面的函数f() 执行一些非法操作，它试图更改所有字符串都有的只读属性——length： function f() { 'abc'.length = 5; } 当你调用上面的函数，它静默失败，赋值操作被简单忽略。让我们将f()在严格模式下运行： function f_strict() { 'use strict'; 'abc'.length = 5; } 现在浏览器报给我们一些错误： f_strict() // TypeError: Cannot assign to read only property 'length' of abc 不是方法的函数中的this在严格模式下，不作为方法的函数中的this值是undefined： function f_strict() { 'use strict'; return this; } console.log(f_strict() === undefined); // true 在非严格模式下，this的值是被称作全局对象（global object）（在浏览器里是window）： function f() { return this; } console.log(f() === window); // true 不再自动创建全局变量在非严格模式下，如果你给不存在的变量赋值，JavaScript会自动创建一个全局变量： function f() { foo = 5 } f() // 不会报错 foo // 5 在严格模式下，这会产生一个错误： function f_strict() { 'use strict'; foo2 = 4; } f_strict() // ReferenceError: foo2 is not defined 深入阅读 揭秘javascript中谜一样的this JavaScript中的this关键字 十二、变量作用域和闭包在JavaScript中，你必须使用变量之前，通过var声明变量： var x; x = 3; y = 4; // ReferenceError: y is not defined 你可以用一条var语句声明和初始化多个变量： var x = 1, y = 2, z = 3; 但我建议每个变量使用一条语句。因此，我将上面的语句重写为： var x = 1; var y = 2; var z = 3; 由于提升（见下文），最好在函数顶部声明变量。 变量和函数作用域变量的作用域总是整个函数（没有块级作用域）。例如： function foo() { var x = -3; if (x &lt; 0) { // (*) var tmp = -x; ... } console.log(tmp); // 3 } 我们可以看到tmp变量不仅在（*）所在行的语句块存在，它在整个函数内都存在。 变量提升变量声明会被提升：声明会被移到函数的顶部，但赋值过程不会。举个例子，在下面的函数中（*）行位置声明了一个变量。 function foo() { console.log(tmp); // undefined if (false) { var tmp = 3; // (*) } } 在内部，上面的函数被执行像下面这样： function foo() { var tmp; // declaration is hoisted console.log(tmp); if (false) { tmp = 3; // assignment stays put } } 闭包每个函数保持和函数体内部变量的连接，甚至离开创建它的作用域之后。例如： function createIncrementor(start) { return function () { // (*) return start++; } } 在（*）行开始的函数在它创建时保留上下文，并在内部保存一个start活动值： var inc = createIncrementor(5); inc() // 5 inc() // 6 inc() // 7 闭包是一个函数加上和其作用域链的链接。因此，createIncrementor()返回的是一个闭包。 IIFE：模拟块级作用域有时你想模拟一个块，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 IIFE(立即执行函数表达式(Immediately Invoked Function Expression))： (function () { // 块开始 var tmp = ...; // 非全局变量 }()); // 块结束 上面你会看到函数表达式被立即执行。外面的括号用来阻止它被解析成函数声明；只有函数表达式能被立即调用。函数体产生一个新的作用域并使tmp变为局部变量。 闭包实现变量共享下面是个经典问题，如果你不知道，会让你费尽思量。因此，先浏览下，对问题有个大概的了解。 闭包保持和外部变量的连接，有时可能和你想像的行为不一致： var result = []; for (var i=0; i &lt; 5; i++) { result.push(function () { return i }); // (*) } console.log(result[1]()); // 5 (不是 1) console.log(result[3]()); // 5 (不是 3) (*)行的返回值总是当前的i值，而不是当函数被创建时的i值。当循环结束后，i的值是5，这是为什么数组中的所有函数的返回值总是一样的。如果你想捕获当前变量的快照，你可以使用IIFE： for (var i=0; i &lt; 5; i++) { (function (i2) { result.push(function () { return i2 }); }(i)); // 复制当前的i } 深入阅读 认识javascript中的作用域和上下文 JavaScript的作用域和提升机制 了解JavaScript的执行上下文 十三、对象和继承和所有的值类型一样，对象有属性。事实上，你可以将对象当作一组属性的集合，每个属性都是一对（键和值）。键是字符串，值可以是任意JavaScript值。到目前为止，我们仅仅见过键是标识符的属性，因为点操作符处理的键必须为标识符。在这节，你讲见到另一种访问属性的方法，能将任意字符串作为键。 单个对象在JavaScript中，你可以直接创建对象，通过对象字面量： var jane = { name: 'Jane', describe: function () { 'use strict'; return 'Person named '+this.name; } }; 上面的对象有两个属性：name和describe。你能读（“get”）和 写（“set”）属性： jane.name // get，'Jane' jane.name = 'John'; // set jane.newProperty = 'abc'; // 自动创建 属性是函数如describe可以被当作方法调用。当调用他们时可以在它们内部通过this引用对象。 jane.describe() // 调用方法,'Person named John' jane.name = 'Jane'; jane.describe() // 'Person named Jane' in操作符用来检测一个属性是否存在： 'newProperty' in jane // true 'foo' in jane // false 若读取一个不存在的属性，将会得到undefined值。因此上面的两个检查也可以像下面这样： jane.newProperty !== undefined // true jane.foo !== undefined // false delete操作符用来删除一个属性： delete jane.newProperty //true 'newProperty' in jane //false 任意键属性属性的键可以是任意字符串。到目前为止，我们看到的对象字面量中的和点操作符后的属性关键字。按这种方法你只能使用标识符。如果你想用其他任意字符串作为键名，你必须在对象字面量里加上引号，并使用方括号获取和设置属性。 var obj = { 'not an identifier': 123 }; obj['not an identifier'] //123 obj['not an identifier'] = 456; 方括号允许你动态计算属性关键字： var x = 'name'; jane[x]; // 'Jane' jane['na'+'me']; // 'Jane' 引用方法如果你引用一个方法，它将失去和对象的连接。就其本身而言，函数不是方法，其中的this值为undefined（严格模式下）。 var func = jane.describe; func() // TypeError: Cannot read property 'name' of undefined 解决办法是使用函数内置的bind()方法。它创建一个新函数，其this值固定为给定的值。 var func2 = jane.describe.bind(jane); func2() // 'Person named Jane' 方法内部的函数每个函数都有一个特殊变量this。如果你在方法内部嵌入函数是很不方便的，因为你不能从函数中访问方法的this。下面是一个例子，我们调用forEach循环一个数组： var jane = { name: 'Jane', friends: [ 'Tarzan', 'Cheeta' ], logHiToFriends: function () { 'use strict'; this.friends.forEach(function (friend) { // 这里的“this”是undefined console.log(this.name + ' says hi to ' + friend); }); } } 调用logHiToFriends会产生错误： jane.logHiToFriends() // TypeError: Cannot read property 'name' of undefined 有两种方法修复这问题。 将this存储在不同的变量。 logHiToFriends: function () { 'use strict'; var that = this; this.friends.forEach(function (friend) { console.log(that.name + ' says hi to ' + friend); }); } forEach的第二个参数允许提供this值。 logHiToFriends: function () { 'use strict'; this.friends.forEach(function (friend) { console.log(this.name + ' says hi to ' + friend); }, this); } 在JavaScript中函数表达式经常被用作函数参数。时刻小心函数表达式中的this。 构造函数：对象工厂除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：如果通过new操作符调用，他们会变为构造函数，对象的工厂。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如： // 设置实例数据 function Point(x, y) { this.x = x; this.y = y; } // 方法 Point.prototype.dist = function () { return Math.sqrt(this.x*this.x + this.y*this.y); }; 我们看到构造函数分为两部分：首先，Point函数设置实例数据。其次，Point.prototype属性包含对象的方法。前者的数据是每个实例私有的，后面的数据是所有实例共享的。 我们通过new操作符调用Point： var p = new Point(3, 5); p.x //3 p.dist(); //5.830951894845301 p是Point的一个实例： p instanceof Point //true typeof p //'object' 深入阅读 Javascript继承 原型的陷阱 Javascript 封装问题 十四、数组数组是数组元素的序列，能通过整数索引方法数组元素，数组索引从0开始。 数组字面量数组字面量创建数组很方便： > var arr = [ 'a', 'b', 'c' ]; 上面的数组有三个元素：分别是字符串“a”，“b”， “c”。你可以通过整数索引访问它们： arr[0] //'a' arr[0] = 'x'; arr // [ 'x', 'b', 'c' ] length属性总表示一个数组有多少项元素。 arr.length //3 除此之外它也可以用来从数组上移除尾部元素： arr.length = 2; arr // [ 'x', 'b' ] in操作符也可以在数组上工作。 1 in arr // arr在索引为1处是否有元素？,true 5 in arr // arr在索引为5处是否有元素？false 值得注意的是数组是对象，因此可以有对象属性： arr.foo = 123; arr.foo // 123 数组方法数组有许多方法。举些例子： var arr = [ 'a', 'b', 'c' ]; arr.slice(1, 2) // 复制元素，[ 'b' ] arr.slice(1) // [ 'b', 'c' ] arr.push('x') // 在末尾添加一个元素，4 arr // [ 'a', 'b', 'c', 'x' ] arr.pop() // 移除最后一个元素，'x' arr // [ 'a', 'b', 'c' ] arr.shift() // 移除第一个元素，'a' arr // [ 'b', 'c' ] arr.unshift('x') // 在前面添加一个元素，3 arr // [ 'x', 'b', 'c' ] arr.indexOf('b') // 查找给定项在数组中的索引，若不存在返回-1， // 1 arr.indexOf('y') // -1 arr.join('-') // 将元素拼接为一个字符串，'x-b-c' arr.join('') // 'xbc' arr.join() // 'x,b,c' 遍历数组有几种方法可以遍历数组元素。其中两个最重要的是forEach和map。 forEach遍历整个数组，并将当前元素和它的索引传递给一个函数： [ 'a', 'b', 'c' ].forEach(function (elem, index) { // (*) console.log(index + '. ' + elem); }); 上面代码的输出 0. a 1. b 2. c 注意（*）行的函数参数是可省略的。例如：它可以只有一个参数elem。 map创建一个新数组，通过给每个存在数组元素应用一个函数： [1,2,3].map(function (x) { return x*x }); // [ 1, 4, 9 ] 深入阅读 有趣的javascript原生数组函数 十五、正则表达式JavaScript内建支持正则表达式。他们被双斜线分隔： /^abc$/ /[A-Za-z0-9]+/ 方法 test()：测试是否匹配/^a+b+$/.test('aaab') // true /^a+b+$/.test('aaa') // false 方法 exec()：匹配和捕获组/a(b+)a/.exec('_abbba_aba_') // [ 'abbba', 'bbb' ] 返回的数组第一项（索引为0）是完整匹配，捕获的第一个分组在第二项（索引为1），等。有一种方法可以反复调用获取所有匹配。 方法 replace()：搜索并替换'&lt;a> &lt;bbb>'.replace(/&lt;(.*?)>/g, '[$1]') // '[a] [bbb]' replace的第一个参数必须是正则表达式，并且开启全局搜索（/g标记），否则仅第一个匹配项会被替换。有一种方法使用一个函数来计算替换项。 十六、数学Math是一个有算数功能的对象。例如： Math.abs(-2) // 2 Math.pow(3, 2) // 3^2 = 9 Math.max(2, -1, 5) //5 Math.round(1.9) // 2 Math.cos(Math.PI) // 预定义常量π，-1 十七、标准库的其他功能JavaScript标准库相对简单，但有很多其他东西你可以使用： Date：日期构造函数，主要功能有转换和创建日期字符串，访问日期组成部分（年，小时等）。JSON：一个对象，功能是转换和生成JSON数据。console.*方法：浏览器的具体方法，不是语言成分的部分，但他们也可以在Node.js中工作。 十八、下一步学什么？在你学会了这篇文章的基础教程后，你可以转到大部分章节末尾提到的高级教程。此外，我建议你看下面的资源： Style guides: I have written a guide to style guides Underscore.js: 一个弥补JavaScript标准库缺少的功能的库 JSbooks – free JavaScript books Frontend rescue: how to keep up to date on frontend technologies http://yanhaijing.com 当然还有我的博客也非常不错哦 http://yanhaijing.com/es5 如果你想成为高手，我建议阅读ecmascript规范 给javascript初学者的24条最佳实践 我希望我知道的七个JavaScript技巧 参考自原文：http://www.2ality.com/2013/06/basic-javascript.html参考自译文：http://yanhaijing.com/basejs/]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用指南]]></title>
    <url>%2F2019%2F07%2F17%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz是一位有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 5. 尝试一下 1. 斜体和粗体*斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~view 斜体或斜体 粗体 加粗斜体 删除线 2. 分级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。 3. 超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1. 行内式语法说明： []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接地址与链接标题前有一个空格。 欢迎来到[liyang's blog](https://liyangzone.com) 欢迎来到[liyang's blog](https://liyangzone.com "liyang's blog") view 欢迎来到liyang’s blog 欢迎来到liyang’s blog 3.2. 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 我经常去的几个网站[Google][1],[YouTube][2],[YouTube][]。 [1]:http://www.google.com [2]:https://www.youtube.com "YouTube" [YouTube]:https://www.youtube.com 我经常去的几个网站Google,YouTube,YouTube。 3.3. 自动链接语法说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/> &lt;address@example.com> view http://example.com/&#97;&#100;&#100;&#x72;&#101;&#x73;&#115;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d; 4. 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 注意： Markdown Extra 只支持在标题后插入锚点，其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。 跳转测试{#toc-heading-18} 跳转到页尾，这个有点问题，会跳转到新标签页的页尾，因为hexo会在生成的a标签上加上target=&quot;_blank&quot;这个属性，暂时无法解决。 5. 列表5.1. 无序列表使用 *，+，- 表示无序列表。 - 无序列表项 一 - 无序列表项 二 - 无序列表项 三 view 无序列表项 一 无序列表项 二 无序列表项 三 5.2. 有序列表有序列表则使用数字接着一个英文句点。 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 view 有序列表项 一 有序列表项 二 有序列表项 三 5.3. 定义型列表语法说明： 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) 代码块 1 Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） view 代码块 1 Markdown轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格）5.3. 列表缩进语法说明： 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 view 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 5.4. 包含段落的列表语法说明： 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ * 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 view 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 5.5. 包含引用的列表语法说明： 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * 阅读的方法: > 打开书本。 > 打开电灯。 view 阅读的方法: 打开书本。打开电灯。 5.6. 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 5.7. 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 会显示成： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 1986\. What a great season. 才会正常显示成： 1986. What a great season. 6. 引用语法说明： 引用需要在被引用的文本前加上&gt;符号。 > 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2. > 无意义的占行文字3. 无意义的占行文字4. view 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4. 6.1. 引用的多层嵌套区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： >>> 请问 Markdwon 怎么用？ - 小白 >> 自己看教程！ - 愤青 > 教程在哪？ - 小白 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 6.2. 引用其它要素引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： > 1. 这是第一行列表项。 > 2. 这是第二行列表项。 > > 给出一些例子代码： > > return shell_exec("echo $input | $markdown_script"); 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 7.1. 行内式语法说明：![图片Alt](图片地址 “图片Title”) 美丽风景： ![美丽风景](https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景") view美丽风景： 7.2. 参考式 语法说明： 在文档要插入图片的地方写![图片Alt][标记] 在文档的最后写上[标记]:图片地址 “Title” ![美丽风景](https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景") [scenery]:https://yuhongjun.github.io/assets/media/scenery.jpeg "美丽风景" view 8. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 效果参见最上方的目录 9. 注脚语法说明： 在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 view 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote^Le 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。 10. LaTeX 公式10.1. $ 表示行内公式：质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 view质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 10.2 $$ 表示整行公式：$$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 11 .表格语法说明： 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 简单方式写表格： 学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92 2.原生方式写表格： |学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92| 3.为表格第二列指定方向： 产品|价格 -|-: Leanote 高级账号|60元/年 Leanote 超级账号|120元/年 view 简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 2.原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 3.为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 12. 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 显示效果都一样 13. 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。 语法说明： 插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 插入多行代码，可以使用缩进或者“code “,具体看示例。 注意： 缩进式插入前方必须有空行 13.1. 行内式C语言里的函数 `scanf()` 怎么使用？ viewC语言里的函数 scanf() 怎么使用？ 13.2. 缩进式多行代码缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world&quot;); }view #include &lt;stdio.h> int main(void) { printf("Hello world"); } 13.3. 用六个`包裹多行代码` ` ` #include &lt;stdio.h> int main(void) { printf("Hello world"); } ` ` ` 另外说明一下，第一个 ```后可以加上代码的类型，js代码就加上js,css就加上css，渲染出来的样式会有区别。比如下面这段，虽然内容基本差不多，第一个是js，第二个是json，渲染出来就是不一样的。如果不加的话文字都是白色的。 var object ={ "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg", "name": "码酱", "introduction": "我不是大佬，只是在追寻大佬的脚步", } { "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg", "name": "码酱", "introduction": "我不是大佬，只是在追寻大佬的脚步" } var object ={ &quot;avatar&quot;: &quot;http://image.luokangyuan.com/1_qq_27922023.jpg&quot;, &quot;name&quot;: &quot;码酱&quot;, &quot;introduction&quot;: &quot;我不是大佬，只是在追寻大佬的脚步&quot;, }13.5. HTML 原始码在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如： 第一个例子： &lt;div class="footer"> © 2018 *** &lt;/div> view © 2018 *** 还有一个流程图，hexo暂时渲染不出来，一般人也用不到，就去掉了。]]></content>
      <categories>
        <category>技术指南</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello，world！]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hello world!]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于我：90后，一名前端开发者，现居上海。 技术宅一枚，喜欢折腾各种电子产品、钻研各种技术。也喜欢骑行、健身等运动。 关于博客: 写这个博客的目的就是分享一些软件技巧、折腾经历、学习记录、日常等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[友情链接]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[相册]]></title>
    <url>%2Fgalleries%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[青海湖骑行记]]></title>
    <url>%2Fgalleries%2F%E9%9D%92%E6%B5%B7%E6%B9%96%E9%AA%91%E8%A1%8C%E8%AE%B0%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[环太湖骑行记]]></title>
    <url>%2Fgalleries%2F%E7%8E%AF%E5%A4%AA%E6%B9%96%E9%AA%91%E8%A1%8C%E8%AE%B0%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2019]]></title>
    <url>%2Fgalleries%2F2019%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2017]]></title>
    <url>%2Fgalleries%2F2017%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2018]]></title>
    <url>%2Fgalleries%2F2018%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[private]]></title>
    <url>%2Fgalleries%2Fprivate%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
